const NASS_KEY = import.meta.env.VITE_NASS_KEY || ''

async function tryFetch(url){
  try {
    const r = await fetch(url, { headers: { 'Accept': 'application/json' } })
    if (!r.ok) throw new Error('HTTP '+r.status)
    return await r.json()
  } catch(e){
    return null
  }
}

// NOTE: AMS/MMN endpoints may have CORS limitations from the browser.
// We attempt lightly; if blocked or empty, we fall back to NASS, then synthetic.
export async function fetchCommoditySeries({ commodity='ORANGES', wFrom=1, wTo=26, yearsBack=5 }){
  const now = new Date()
  const year = now.getUTCFullYear()
  const years = Array.from({length: yearsBack}, (_,i)=> year - i)

  // Attempt NASS Quick Stats for price averages (example, varies by commodity/attribute)
  // Docs: https://quickstats.nass.usda.gov/
  async function fetchNass(year, week){
    if (!NASS_KEY) return null
    const q = new URLSearchParams({
      key: NASS_KEY,
      commodity_desc: commodity.toUpperCase(),
      year: String(year)
    })
    // Week filtering is not universal; many series lack week granularity.
    // We will filter client-side if 'week_end' or 'week' exists.
    const url = https://quickstats.nass.usda.gov/api/api_GET/?
    const json = await tryFetch(url)
    if (!json || !json.data) return null
    // map to {week, price}
    const rows = json.data
      .map(r=>{
        const wk = Number(r.week || r.week_ending || r.week_end || r.periode || r.period) || null
        const price = Number(r.value?.toString().replace(/,/g,'')) || null
        return wk && price ? { week: wk, price } : null
      })
      .filter(Boolean)
    return rows
  }

  // Synthetic fallback: deterministic pattern so UI/graphs work offline/demo
  function synthetic(year){
    const base = 10 + Math.random()*2
    const arr = []
    for (let w=wFrom; w<=wTo; w++){
      const seasonal = Math.sin((w/26)*Math.PI) * 2
      const trend = (year % 5) * 0.3
      const noise = ((w*year)%7)*0.05
      arr.push({ week: w, price: +(base + seasonal + trend + noise).toFixed(2) })
    }
    return arr
  }

  const series = []
  for (const y of years){
    let rows = await fetchNass(y, wFrom)
    if (!rows || rows.length===0){
      rows = synthetic(y)
    } else {
      // keep only requested weeks and fill small gaps
      rows = rows
        .filter(r => r.week>=wFrom && r.week<=wTo)
        .sort((a,b)=>a.week-b.week)
      const have = new Set(rows.map(r=>r.week))
      for (let w=wFrom; w<=wTo; w++){
        if (!have.has(w)){
          const prev = rows.findLast(r=>r.week < w)?.price ?? rows[0]?.price ?? 10
          rows.push({ week: w, price: prev })
        }
      }
      rows.sort((a,b)=>a.week-b.week)
    }
    series.push({ year: y, rows })
  }
  return series
}